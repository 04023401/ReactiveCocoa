/// Represents an action that will perform side effects or a transformation when
/// executed with an input.
///
/// Actions enforce serial execution. Any attempt to execute an action multiple
/// times concurrently will return an error.
public final class Action<Input, Output> {
	private let executeClosure: Input -> SignalProducer<Output>
	private let valuesObserver: Signal<Output>.Observer
	private let errorsObserver: Signal<NSError>.Observer

	/// A signal of all values generated from applications of the Action.
	///
	/// In other words, this will send every value from every signal generated
	/// by each SignalProducer returned from apply().
	public let values: Signal<Output>

	/// A signal of all errors generated from applications of the Action,
	/// _except_ `RACAction.ActionNotEnabled` errors.
	///
	/// In other words, this will send errors from every signal generated by
	/// each SignalProducer returned from apply().
	public let errors: Signal<NSError>

	/// Whether the action is currently executing.
	public var executing: PropertyOf<Bool> {
		return PropertyOf(_executing)
	}

	private let _executing: MutableProperty<Bool> = MutableProperty(false)

	/// Whether the action is currently enabled.
	public var enabled: PropertyOf<Bool> {
		let property = MutableProperty(false)

		userEnabled.producer
			|> combineLatestWith(executing.producer)
			|> map(self.dynamicType.shouldBeEnabled)
			// FIXME: Workaround for <~ being disabled on SignalProducers.
			|> startWithSignal { signal, disposable in
				let bindDisposable = property <~ signal
				disposable.addDisposable(bindDisposable)
			}

		return PropertyOf(property)
	}

	/// Whether the instantiator of this action wants it to be enabled.
	private let userEnabled: PropertyOf<Bool>

	/// This queue is used for read-modify-write operations on the `_executing`
	/// property.
	private let executingQueue = dispatch_queue_create("org.reactivecocoa.ReactiveCocoa.Action.executingQueue", DISPATCH_QUEUE_SERIAL)

	/// Whether the action should be enabled for the given combination of user
	/// enabledness and executing status.
	private class func shouldBeEnabled(#userEnabled: Bool, executing: Bool) -> Bool {
		return userEnabled && !executing
	}

	/// Initializes an action that will be conditionally enabled, and create a
	/// SignalProducer for each input.
	public init<P: PropertyType where P.Value == Bool>(enabledIf: P, _ execute: Input -> SignalProducer<Output>) {
		executeClosure = execute
		userEnabled = PropertyOf(enabledIf)

		let (vSig, vSink) = Signal<Output>.pipe()
		valuesObserver = vSink
		values = vSig

		let (eSig, eSink) = Signal<NSError>.pipe()
		errorsObserver = eSink
		errors = eSig
	}

	/// Initializes an action that will be enabled by default, and create a
	/// SignalProducer for each input.
	public convenience init(_ execute: Input -> SignalProducer<Output>) {
		self.init(enabledIf: ConstantProperty(true), execute)
	}

	deinit {
		sendCompleted(valuesObserver)
		sendCompleted(errorsObserver)
	}

	/// Creates a SignalProducer that, when started, will execute the action
	/// with the given input, then forward the results upon the produced Signal.
	///
	/// If the action is disabled when the returned SignalProducer is started,
	/// the produced signal will send an `NSError` corresponding to
	/// `RACError.ActionNotEnabled`, and nothing will be sent upon `values` or
	/// `errors` for that particular signal.
	public func apply(input: Input) -> SignalProducer<Output> {
		return SignalProducer { observer, disposable in
			var startedExecuting = false

			dispatch_sync(self.executingQueue) {
				if self.dynamicType.shouldBeEnabled(userEnabled: self.userEnabled.value, executing: self._executing.value) {
					self._executing.value = true
					startedExecuting = true
				}
			}

			if !startedExecuting {
				sendError(observer, RACError.ActionNotEnabled.error)
				return
			}

			self.executeClosure(input).startWithSignal { signal, signalDisposable in
				disposable.addDisposable(signalDisposable)
				signal.observe(observer)

				signal.observe(next: { value in
					sendNext(self.valuesObserver, value)
				}, error: { error in
					sendNext(self.errorsObserver, error)
				})
			}

			disposable.addDisposable {
				self._executing.value = false
			}
		}
	}
}
